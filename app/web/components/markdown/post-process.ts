import { type MutableRefObject } from "react";
import { type Config } from "../../../types";
import { appendDisabledLinkTooltip } from "../../utils";
import { type WebsocketContext } from "../websocket-provider/context";

export function postProcessMarkdown({
    wsRequest,
    markdownElement,
    single_file,
    skipScroll,
}: {
    wsRequest: WebsocketContext["wsRequest"];
    markdownElement: HTMLElement;
    single_file: Config["single_file"] | undefined;
    skipScroll: MutableRefObject<boolean>;
}) {
    // handle links
    const base = window.location.origin + "/";
    markdownElement.querySelectorAll("a").forEach((element) => {
        if (!element.href.startsWith(base)) {
            // if link is not relative, fallback to default behaviour
            return;
        }

        // override onClick on relative links
        element.addEventListener("click", (event) => {
            event.preventDefault();
            const pathname = element.href.slice(base.length);
            wsRequest({ type: "get_entry", path: pathname });
        });

        // we only override behaviour for single_file mode
        if (!single_file) return;

        // if relative link points to an anchor in currentPath, do nothing
        // and fallback to default behaviour
        const currentUrl = window.location.origin + window.location.pathname;
        if (element.href.slice(currentUrl.length).startsWith("#")) {
            return;
        }

        appendDisabledLinkTooltip(element);
    });

    // intercept clicks to "details" tags to set a flag to disable scrolling
    // it's annoying when you open/close a "details" tag and there's an auto scroll
    markdownElement.querySelectorAll("details").forEach((element, index) => {
        element.addEventListener(
            "click",
            () => {
                skipScroll.current = true;
            },
            {
                capture: true,
            },
        );
        console.log(`details ${index}: `, element);
    });
}

export function evalPantsdownScript(markdownElement: HTMLElement) {
    // We find the code-copy <script> generated by pantsdown
    // and create a new <script> element to be appended
    // to the document or else the script is not executed
    const script: HTMLScriptElement = markdownElement.querySelector("#code-copy-script")!;
    const newScript = document.createElement("script");
    newScript.text = script.innerText;
    markdownElement.appendChild(newScript);
}

export function updateElementsStyles({
    lines,
    fileExt,
    markdownElement,
    cursorLineElement,
    lineNumbersElement,
}: {
    lines: string[];
    fileExt: string | undefined;
    markdownElement: HTMLElement;
    cursorLineElement: HTMLElement;
    lineNumbersElement: HTMLElement;
}) {
    if (fileExt === "md") {
        markdownElement.style.setProperty("padding", "44px");
        markdownElement.style.setProperty("max-width", "1012px");
        cursorLineElement.style.removeProperty("transform");
        lineNumbersElement.style.setProperty("display", "none");
    } else {
        // rendering code file
        markdownElement.style.setProperty("padding", "20px 0 0 60px");
        markdownElement.style.removeProperty("max-width");
        // move cursorLineElement up so line of code is vertically centered
        cursorLineElement.style.setProperty("transform", "translateY(-9px)");
        lineNumbersElement.style.setProperty("display", lines.length ? "block" : "none");

        // Change code background color to canvas default when displaying only code
        const codeContainer = markdownElement.getElementsByTagName("pre")[0];
        if (codeContainer) {
            codeContainer.style.setProperty("padding", "0px 16px");
            codeContainer.style.setProperty("background", "var(--color-canvas-default)");
        }
    }
}
